package lesson_23.homeworkAndrey_2;

import java.util.Arrays;

/**
 * Главный класс приложения
 */
public class Main {

    /**
     * Размер исходного массива
     */
    private static int size = 10_000_000;

    /**
     * Размер половины массива (для обработки в два потока)
     */
    private static int half = size / 2;

    /**
     * Произвольный индекс ячейки для проверки корректного значения после обработки
     */
    private static int check = 5_678_432;

    /**
     * Исходный массив
     */
    private static float[] array = new float[size];

    /**
     * Переменная, определяющая, на сколько кусков будет разбиваться исходный массив при многопоточной обработке,
     * соответственно, столько потоков и будет создано для обработки массива
     */
    private static int divider = 5;

    /**
     * Точка старта приложения
     *
     * @param args передаваемые при старте аргументы
     */
    public static void main(String[] args) {

        // Обрабатываем массив в один поток
        simpleProcessing();
        // Обрабатываем массив в два потока
        threadProcessing();
        // Обрабатываем массив произвольным количеством потоков (задаётся в переменной divider)
        multipleThreadProcessing();
    }

    /**
     * Метод, обрабатывающий массив произвольным количеством потоков (задаётся в переменной divider)
     */
    private static void multipleThreadProcessing() {

        // Заполняем массив единицами
        arrayInit();

        // Засекаем время старта операции
        long timer = System.currentTimeMillis();

        // Вычисляем размер одного кусочка массива
        int massiveSize = size / divider;

        // Создаём двумерный массив, у которого количество строк будет равно количеству, на которое мы делим исходный
        // массив, а каждая строка по сути будет являться отдельным кусочком этого исходного массива.
        // То есть, например, если разбиваем массив на 5 кусочков, то это будет массив из пяти строк длиной 2_000_000.
        // Первая строка будет содержать ячейки с 0 по 1_999_999 исходного массива, вторая строка будет содержать
        // ячейки с 2_000_000 по 3_999_999 исходного массива и так далее.
        // То есть фактически мы наш исходный одномерный массив разбиваем на двумерный массив, где каждую строку
        // будет обрабатывать отдельный поток.
        float[][] multArrays = new float[divider][];

        // Создаём массив объектов-обработчиков (сколько кусочков массива, столько и объектов-обработчиков)
        ArrayProcessor[] arrayProcessors = new ArrayProcessor[divider];

        // Создаём массив потоков, которые будут обрабатывать исходный массив
        // (сколько кусочков массива, столько и потоков)
        Thread[] threads = new Thread[divider];

        // Этот цикл отработает столько раз, на сколько кусочков мы разделили исходный массив
        for (int i = 0; i < multArrays.length; i++) {

            // В нашем двумерном массиве создаём строку, которая будет заполнена определённым кусочком исходного массива.
            // Например, если это первая итерация цикла (i == 0), то в двумерном массиве под индексом 0 создастся
            // кусочек массива нужного размера, при второй итерации создастся второй кусочек под индексом 1 и т.д.
            multArrays[i] = new float[massiveSize];

            // Далее заполняем этот созданный кусочек значениями из исходного массива, причём то место исходного массива,
            // откуда именно мы берём значения зависит от итерации цикла, т.к. высчитывается в зависимости от i.
            // Например, при первой итерации кусочек массива будет заполнен значениями исходного массива из ячеек
            // от 0 до 1_999_999 (если кусочков пять), при второй итерации - от 2_000_000 до 3_999_999 и т.д.
            // Можно было конечно сразу заполнять кусочки единицами, но по условию задачи мы должны разбивать именно
            // исходный массив, поэтому так и делаем.
            System.arraycopy(array, massiveSize * i, multArrays[i], 0, massiveSize);

            // Создаём объект класса-обработчика, куда передаём именно нужный кусочек массива (в зависимости от i),
            // а также значение коррекции, которое тоже зависит от i. Например, при первой итерации цикла значение
            // коррекции будет 0, т.к. нам не нужно ничего корректировать, в первом кусочке у нас итак содержатся
            // значения из начала исходного массива. А вот при второй итерации цикла и размере кусочка 2_000_000
            // значение коррекции будет уже 2_000_000, при третей итерации значение коррекции будет 4_000_000 и т.д.
            // Созданный объект класса-обработчика помещаем на соответствующее ему место в массиве обработчиков.
            arrayProcessors[i] = new ArrayProcessor(multArrays[i], massiveSize * i);

            // Создаём поток, куда передаём нужный класс-обработчик из массива обработчиков (опять же зависит от
            // итерации цикла). Помещаем поток на соответствующее ему место в массиве потоков.
            threads[i] = new Thread(arrayProcessors[i]);

            // Запускаем нужный поток из массива потоков (зависит от итерации цикла).
            threads[i].start();
        }

        // Заставляем главный поток ожидать окончания работы всех запущенных потоков из массива потоков
        for (Thread thread : threads) {
            try {
                thread.join();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        }

        // В цикле склеиваем все кусочки обратно в исходный массив.
        // То есть по сути преобразуем двумерный массив обратно в одномерный массив исходного размера.
        for (int i = 0; i < multArrays.length; i++) {
            System.arraycopy(multArrays[i], 0, array, massiveSize * i, massiveSize);
        }

        // Вычисляем время, затраченное на операцию, и выводим его в консоль
        System.out.println("Время выполнения в несколько потоков - " + (System.currentTimeMillis() - timer) + " миллисекунд");
        // Выводим в консоль значение произвольной ячейки массива для проверки. Независимо от количества потоков
        // это значение должно быть одинаковым, иначе обработка массива произведена неверно.
        System.out.println("Проверочное значение - " + array[check]);
    }

    /**
     * Метод, обрабатывающий массив в два потока
     */
    private static void threadProcessing() {

        // Заполняем массив единицами
        arrayInit();

        // Засекаем время старта операции
        long timer = System.currentTimeMillis();

        // Создаём два массива, каждый из которых равен половине исходного
        float[] array1 = new float[half];
        float[] array2 = new float[half];

        // Копируем первую половину исходного в первый массив, а вторую половину во второй массив
        System.arraycopy(array, 0, array1, 0, half);
        System.arraycopy(array, half, array2, 0, half);

        // Создаём два объекта класса-обработчика. Второму объекту при этом передаём значение коррекции
        ArrayProcessor arrayProcessor1 = new ArrayProcessor(array1, 0);
        ArrayProcessor arrayProcessor2 = new ArrayProcessor(array2, half);

        // Создаём два потока для обработки половинок массива
        Thread thread1 = new Thread(arrayProcessor1);
        Thread thread2 = new Thread(arrayProcessor2);

        // Запускаем оба потока
        thread1.start();
        thread2.start();
        try {
            // Заставляем главный поток ожидать окончания работы двух созданных потоков
            thread1.join();
            thread2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // Склеиваем обработанные половинки массива обратно в целый массив
        System.arraycopy(array1, 0, array, 0, half);
        System.arraycopy(array2, 0, array, half, half);

        // Вычисляем время, затраченное на операцию, и выводим его в консоль
        System.out.println("Время выполнения в 2 потока - " + (System.currentTimeMillis() - timer) + " миллисекунд");
        // Выводим в консоль значение произвольной ячейки массива для проверки. Независимо от количества потоков
        // это значение должно быть одинаковым, иначе обработка массива произведена неверно.
        System.out.println("Проверочное значение - " + array[check]);
    }

    /**
     * Метод, обрабатывающий массив в один поток
     */
    private static void simpleProcessing() {

        // Заполняем массив единицами
        arrayInit();

        // Засекаем время старта операции
        long timer = System.currentTimeMillis();

        // Создаём объект класса-обработчика и передаём туда весь массив и значение коррекции 0,
        // т.к. в данном случае ничего корректировать не нужно, массив обрабатывается одним куском.
        ArrayProcessor arrayProcessor = new ArrayProcessor(array, 0);

        // Запускаем обработку массива. Вызываем именно метод run, а не start, т.к. нам не нужен в данном случае
        // отдельный поток, метод вызываем как обычный метод (не многопоточный), обработка производится здесь же,
        // в главном потоке.
        arrayProcessor.run();

        // Вычисляем время, затраченное на операцию, и выводим его в консоль
        System.out.println("Время выполнения в 1 поток - " + (System.currentTimeMillis() - timer) + " миллисекунд");
        // Выводим в консоль значение произвольной ячейки массива для проверки. Независимо от количества потоков
        // это значение должно быть одинаковым, иначе обработка массива произведена неверно.
        System.out.println("Проверочное значение - " + array[check]);
    }

    /**
     * Метод заполняет массив единицами
     */
    private static void arrayInit() {
        Arrays.fill(array, 1);
    }
}